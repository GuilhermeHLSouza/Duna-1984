
# Duna 1984 - Documentação  
<br>  
<table>  
  <tr>  
    <td>  
      <p>Projeto realizado por Guilherme Fonseca da Silva e Guilherme Henrique Lemes de Souza, baseado na cena icônica do filme Duna (1984). A cena combina elementos cinematográficos com uma jogabilidade interativa para criar uma experiência imersiva, utilizando referências visuais e músicas do filme original.</p>  
    </td>  
  </tr>  
</table>  
<br> 

## Descrição da Obra Original  
<p>
  Duna (1984), dirigido por David Lynch, é uma adaptação cinematográfica do clássico romance de ficção científica de Frank Herbert. A história é ambientada no deserto de Arrakis, um planeta essencial por sua produção da "Especiaria Melange", um recurso valioso que garante poder e longevidade. A trama acompanha Paul Atreides, herdeiro da Casa Atreides, enquanto ele enfrenta intrigas políticas, traições e uma jornada de autodescoberta.  

O filme é conhecido por sua estética surreal e única, com uma direção de arte detalhada que captura o misticismo e a vastidão do universo de Duna. Apesar de controverso na época de seu lançamento, a obra se tornou um marco visual e temático, explorando temas como poder, ecologia e destino. </p> 

## Explicação da cena original do filme
<p>
  Na cena original de Duna (1984), Paul Atreides utiliza um gancho para escalar o imenso verme de areia, uma criatura colossal que domina o deserto de Arrakis. A sequência destaca a determinação e o controle de Paul ao conquistar o verme, demonstrando seu crescimento como líder dos Fremen. O momento é crucial para sua jornada, simbolizando a conexão dele com o deserto e sua aceitação do destino como o Kwisatz Haderach (aquele que pode ver as memórias dos ancestrais), enquanto ele utiliza o verme como transporte através das vastas dunas de areia. </p>

## Explicação do jogo  

<p>O jogo se inicia com o jogador controlando Paul em cima do verme, desviando de pedras que aparecem no caminho. O jogador vence ao sobreviver por 2 minutos sem colidir com nenhuma pedra, retornando ao menu inicial ao fim do desafio. Caso o verme colida com uma pedra, uma tela de game over é exibida. O jogo possui menus interativos, músicas do filme e uma estética fiel ao universo visual de Duna. </p>  
<br>  

## Cenário e Ambientação
<p>O cenário do jogo foi projetado para capturar a atmosfera do deserto de Arrakis, utilizando um campo de visão (Field of View - FOV) com tonalidade amarelada. Essa escolha visual reforça a sensação de calor intenso e vastidão do deserto, transportando o jogador para o ambiente de Duna.

Para construir o cenário, utilizamos um prefab de terreno desértico, que foi ajustado e integrado ao jogo. Esse prefab inclui textura de areia realista e elementos visuais que remetem ao filme, como a imensidão sem fim do horizonte e a movimentação sutil da areia com o vento. Essa abordagem permitiu criar um ambiente imersivo, conectando visualmente o jogo à obra cinematográfica.</p>
<br>


## Paleta de Cores  

<p>A paleta de cores do jogo foi escolhida para refletir a estética do filme Duna (1984) e reforçar a ambientação do deserto de Arrakis. Tons terrosos, como areia, dourado e marrom, dominam o cenário, criando uma sensação de aridez e vastidão.  

Os elementos visuais principais, como o traje de destilação de Paul Atreides e o verme de areia, foram destacados com tons mais escuros, como preto e cinza, para contrastar com o fundo amarelado do deserto. A tonalidade amarelada aplicada ao campo de visão do jogador ajuda a transmitir a intensidade do sol e o calor característico de Arrakis, aumentando a imersão no mundo do jogo.</p>
<br>


## Personagens  

### Protagonista  

<p>Paul Atreides é o protagonista da história. Durante o jogo, ele monta o verme de areia em um momento crucial de sua jornada, representando sua conexão com o deserto de Arrakis e sua transformação como líder. Sua aparência segue o traje típico do deserto (traje de destilação), destacando tons escuros.</p>  
<table>  
<thead>
  <th>
    
  ![Imagem de Paul](https://github.com/user-attachments/assets/870b8ffa-c17f-499b-973e-daf9b7cd1b61)
  </th>
</thead>  
</table>  

### Verme de areia  

<p>O verme de areia é uma criatura icônica de Arrakis. Ele serve como o principal elemento visual e mecânico do jogo, movendo-se pelo deserto enquanto o jogador desvia de obstáculos no caminho. Sua aparência é fiel ao design do filme.</p>  
<table>  
<thead>  
  <th> 
    Feito totalmente no software 3d blender pela dupla.
    
![Imagem verme de areia](https://github.com/user-attachments/assets/b6168abf-0db9-45df-aae1-7f4c619d765b)
  </th>  
</thead>  
</table>  

## Obstáculos  

<p>Os obstáculos consistem em pedras que aparecem aleatoriamente no caminho do verme de areia. Esses elementos foram projetados para criar um desafio ao jogador, exigindo atenção e reflexos rápidos.</p>  
<table>  
<thead>  
  <th>
    
  ![Imgem pedras usadas de obstacúlo](https://github.com/user-attachments/assets/e036740b-1020-482e-8b5c-4b97780be6b8)
  </th>  
</thead>  
</table>  
<br>  

## Menus 
Feitos totalmente pelo site Canva.

### Menu Principal  

 • Tela inicial com botões interativos: jogar, e sair.  
 • Os botões mudam de cor ao passar o mouse por cima, proporcionando uma experiência dinâmica.  
<table>  
<thead>  
  <th> 
    
  ![Imagem do menu principal](https://github.com/user-attachments/assets/474f0874-afea-4ca1-b0f6-26e11dee176d)
  </th>  
</thead>  
</table>   

### Game Over  

 • Tela exibida caso o verme de areia colida com uma pedra.  
 • Contém a opção de reiniciar o jogo, retornando ao menu principal.  
<table>  
<thead>  
  <th>  
    
   ![Imagem do game over](https://github.com/user-attachments/assets/110c557d-bfb3-485c-8bbe-b8ac8a8fa3d3)
  </th>  
</thead>  
</table>

## Músicas do jogo  

<p>As músicas utilizadas no jogo foram escolhidas para refletir a atmosfera de Duna (1984) e proporcionar uma experiência imersiva. No menu principal, a trilha sonora é composta por "Dune (Desert Theme)" e "Main Title", ambas da banda Toto, responsáveis pela trilha sonora original do filme. Essas músicas capturam a grandiosidade e o mistério do universo de Arrakis, conectando o jogador diretamente à estética sonora do filme.</p>  

## Diagramas de classes (antigo e corrigido)

### Antigo
Imagem do antigo diagrama de classes.
<br>

<table>
  <head>
    <th>
      
  ![931b5ad6-3b96-4cdc-8271-ef4c5d4b07b1](https://github.com/user-attachments/assets/bbd3fe3b-97ea-4cf3-b726-5a4cd2557be3)
    </th>
  </head>
</table>

### Corrigido

Imagem do diagrama de classes corrigido.
<br>

<table>
  <head>
    <th>
      
  ![4b5abfba-f3a0-4e73-ab96-85eb118b970b](https://github.com/user-attachments/assets/acc780a3-e3da-495a-a25a-aa33c7fc05b9)
    </th>
  </head>
</table>

## Descrição técnica do jogo

 Criamos uma cena na unity utilizando assets pegos na internet e alguns feitos por nós mesmo no Blender. O cenário foi criado com prefabs para facilitar a criação de várias repetições do mesmo. Também temos um menu para iniciar a cena ou fechar fechar o jogo, 
Foi criado scripts para o personagem, para  a câmera, para as pedras, para o gerador de pedras, para o menu e para o timer.

scripts: 

Personagem: Utiliza uma variável do tipo Vector3 onde o valor será informado na unity para  setar a posição inicial do personagem, a partir disso o método Movimento cria o movimento do personagem utilizando condicionais para verificar as teclas A e D;

Câmera: Acompanha o personagem por meio de uma variável do tipo GameObject, onde vai pegar  o posição z do personagem e verifica se é a mesma, caso não seja ele leva a câmera para a mesma posição do eixo z pega pela variável;

Pedras: As pedras seguem pelo eixo x em direção ao personagem em uma velocidade determinada pela variável “mov”, utilizamos o OnCollisionEnter para verificar um colisão com o personagem por meio da tag “Jogador”;

GeradorPedra: Gera pedras aleatórias, enquanto se movimenta em zig zag; 

Menu: Dois métodos foram criados para administrar os botões do menu sendo eles “Jogar” e “Sair”.  

Tempo: Gerencia o tempo colocado na  da tela quando o tempo chega a zero ele leva para o Menu.

## Códigos do jogo  

 Imagens de todos os scripts comentados e com suas devidas explicações. 
<br>  

### Menu Principal e Game over

Scripts que gerenciam os botões e suas funções, como iniciar o jogo, acessar as configurações, sair e fim do jogo.  
<table>  
<thead>  

```csharp

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Menu : MonoBehaviour
{
    public string nomeCena;
    //criando o metodo Jogar que será ativo quando o jogador apertar o botão Jogar
    public void Jogar()
    {
        SceneManager.LoadSceneAsync(nomeCena); //chamado uma determinada cena
    }
    
    //criando o metodo Sair que será chamadp quando o jogador apertar o botão sair
    public void Sair()
    {
        Application.Quit(); //saindo do Jogo 
    }
}

``` 
</thead>  
</table>  
<br>  

### Câmera  

Script que ajusta a câmera para acompanhar o movimento do verme no deserto.  
<table>  
<thead>  

```csharp
  
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Camera : MonoBehaviour
{
    public GameObject personagem;
    public Vector3 posicao;
    // Start is called before the first frame update
    void Start()
    {
        //colocando a camera na posição do personagem/minhoca
        posicao.z = personagem.transform.position.z -2.5f ;
        transform.position = posicao;
    }

    // Update is called once per frame
    void Update()
    {
        //verificando se camera está na posição do personagem
        if(personagem.transform.position.z != transform.position.z) 
        {
            //movendo a minhoca para a posição do personagem
            posicao = new Vector3(transform.position.x, transform.position.y, personagem.transform.position.z -2.50f);
            transform.position = posicao ;
        }
       
    }
}

```  
   
</thead>  
</table>  
<br>  

### Pedras  

Configuração do modelo 3D das pedras usadas como obstáculos no jogo.  
<table>  
<thead>  

```csharp

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Pedra : MonoBehaviour
{
    public Vector3 mov;
    public Vector3 tamanho;
    // Start is called before the first frame update
    void Start()
    {
        //definindo um tamanho para a pedra
        tamanho = new Vector3(10f, 10f, 10f);
        transform.localScale = tamanho;
    }

    // Update is called once per frame
    void Update()
    {
        //definindo o valor da velocidade que a pedra vai se mover
        mov = new Vector3(-0.3f, 0, 0);
        //chamando o metodo Movimento
        Movimento(mov);
    }

    //incluindo o metodo Movimento 
    void Movimento(Vector3 movimento)
    {
        //fazendo o movimento
        transform.Translate(movimento);
    }

    //colocando a colisão nas pedras
    private void OnCollisionEnter(Collision collision)
    {
        //verificando em qual objeto está colidindo
        if (collision.gameObject.tag == "Jogador")
        {
            //chamando a cena FimJogo
            SceneManager.LoadSceneAsync("FimJogo");
        }
        if (collision.gameObject.tag == "Final")
        {
            //Destruindo o Objeto 
            Destroy(this.gameObject);
        }
    }
}

```
 
</thead>  
</table>  
<br>  

### Geração das Pedras  

Código que gera as pedras aleatoriamente no caminho do verme.  
<table>  
<thead>

  ```csharp

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GeracaoPedra : MonoBehaviour
{
    int random;
    public Vector3 posicaoInicial;
    public GameObject[] obstaculos;
    public float spawnTime, spawnDelay;
    public float velocidade = 5.0f;     
    public float velocidadeZigZag;
    public float limiteSuperior;
    public float limiteInferior;
    private int direcaoZ = 1;

    // Start is called before the first frame update
    void Start()
    {
        //invocando os objetos repetidamente utilizando o metodo SpawnRandom
        InvokeRepeating("SpawnAleatorio", spawnTime, spawnDelay);
        //colocando o objeto na posição certa
        transform.position = posicaoInicial;
    }
    
    void SpawnAleatorio()
    {
        //pega um numero aleatorio de 0 até a quandidade de obstaculos que foi colocado na variavel obstaculos
        random = Random.Range(0, obstaculos.Length);
        //coloca um dos objetos presentes na variavel na cena aleatoriamente a partir da variavel random  
        Instantiate(obstaculos[random], transform.position, transform.rotation);
    }

    // Update is called once per frame
    void Update()
    {
        //define qual a direção o objeto vai estar indo
        Vector3 movimentoZigZag = Vector3.forward * direcaoZ * velocidadeZigZag * Time.deltaTime;
        transform.Translate(movimentoZigZag);

        //verificando se atingiu os limites colocados
        if (transform.position.z >= limiteSuperior)
        {
            direcaoZ = -1;
        }
        else if (transform.position.z <= limiteInferior)
        {
            direcaoZ = 1; 
        }
    }
}

```

</thead>  
</table>  
<br>  

### Timer  

Scripts que criam um cronômetro e verifica se chegou no final gerando a condição de vitória.  
<table>  
<thead>  
  
```csharp
  
using System.Collections;
using System.Collections.Generic;
using System.Timers;
using UnityEngine.SceneManagement;
using UnityEngine;
using TMPro;

public class Tempo : MonoBehaviour
{
    public TextMeshProUGUI textTempo;
    public float tempo;
    private int minutos;
    private int segundos;

    // Update is called once per frame
    void Update()
    {
        tempo -= Time.deltaTime;
        if (tempo < 0)
        {
            SceneManager.LoadSceneAsync("Menu");
            tempo = 0;
        }
        minutos = Mathf.FloorToInt(tempo / 60);
        segundos = Mathf.FloorToInt(tempo % 60);
        textTempo.text = string.Format("{0:00}:{1:00}", minutos, segundos );
    }
}

```

</thead>  
</table>  
<br>  

## Movimentação do verme de areia  

Código que controla o movimento contínuo do verme e a detecção de colisões com obstáculos.  
<table>  
<thead>  
  
```csharp
  
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

public class Personagem : MonoBehaviour
{
    public Vector3 mov;
    private Animator anim;

    // Start is called before the first frame update
    void Start()
    {
        //colocando a posição inicial do personagem/minhoca
        transform.position = mov;
        //puxando o componente Animator do personagem/minhoca
        anim = GetComponent<Animator>();
    }

    // Update is called once per frame
    void Update()
    {
        //chamando o metodo Movimento
        Movimento();
    }

    //criando o metodo Movimento
    void Movimento()
    {
        //verificando se a tecla A foi clicada e se não passou do limite do mapa 
        if(Input.GetKey(KeyCode.A) && transform.position.z < 186.15)
        {
            mov = new Vector3 (10f * Time.deltaTime, 0f, 0f);
            transform.Translate(mov);
            anim.SetBool("Esquerda", true);
        }

        //verificando se a tecla A não está ativa 
        else if (Input.GetKeyUp(KeyCode.A) || Input.GetKeyUp(KeyCode.LeftArrow))
        {   
            anim.SetBool("Esquerda", false);
        }
         
        //verificando se a tecla D foi clicada e se não passou do limite do mapa 
        if (Input.GetKey(KeyCode.D) && transform.position.z > 162.68)
        {
            mov = new Vector3(-10f * Time.deltaTime, 0f, 0);
            transform.Translate(mov);
            anim.SetBool("Direita", true);
        }
        
        //verificando se a tecla D não está ativa 
        else if (Input.GetKeyUp(KeyCode.D) || Input.GetKeyUp(KeyCode.RightArrow))
        {
            anim.SetBool("Direita", false);
        }
    }
}

```

</thead>  
</table>  
<br>  

## Organização e execução  

<p>
O projeto foi desenvolvido por Guilherme Fonseca e Guilherme Henrique, com uma divisão clara de tarefas. Guilherme Fonseca se concentrou na parte visual e teórica, trabalhando nas artes, modelos 3D e no desenvolvimento da documentação. Já Guilherme Henrique focou na programação, sendo responsável pela implementação técnica das mecânicas do jogo.  

Ambos mantiveram uma comunicação constante, garantindo que cada um estivesse ciente de como tudo estava funcionando, tanto na parte teórica quanto na programação. Essa abordagem ajudou a alinhar o trabalho e evitar problemas de integração. </p>

## Vídeo  

Vídeo de apresentação básica das mecânicas do jogo (clique na imagem abaixo para abrir o vídeo em outra aba do navegador).  

[![videojogo](https://github.com/user-attachments/assets/9d4648fd-f5a6-46e5-b9bd-0d73237dce44)](https://github.com/user-attachments/assets/5c0ad74c-69f0-4dcf-8954-057bd50c6fdd)
[Video](https://drive.google.com/file/d/1Q0Rw71gnELjPvNhQtDASFGgyQBlOhE5f/view?usp=sharing)

<br>  

> ### Referências  

 [Proganista](https://sketchfab.com/3d-models/fremen-of-dune-fb4be07a655a47f890f1ff1d42f7f57e)
 
 [Deserto](https://sketchfab.com/3d-models/dune-arrakis-wip-58bd8be249944f1b892a52eb52e06024)
 
 [Pedras usadas de obstáculo](https://assetstore.unity.com/packages/3d/environments/landscapes/stylized-low-poly-rocks-271334)

 [Música do menu principal](https://youtu.be/oauF0jXcAq8?si=goZx5islc5gG6Zvs)

 [Música do jogo](https://youtu.be/yE4pPzrkgsM?si=WzNQ7ztFg0gi-7A5)
 
